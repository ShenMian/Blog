# 迭代器模式

**英文**: Iterator pattern.  

迭代器类似自定义的指针, 拥有和指针类似的使用方式, 但却允许不同数据结构以相同的方法进行遍历.  

以数组和链表为例, 数组的元素在内存中是紧密相连的, 但链表在内存中不是紧密相连的, 因此两者获取下一个元素的方法不同. 迭代器则用于封装这部分代码, 使不同数据结构可以使用相同的方法进行遍历.

下面简单实现了一个数组并提供了迭代器. 由于此时迭代器的行为和指针最接近, 所以代码最简单易懂.

```cpp
#include <cstddef>
#include <iostream>
#include <numeric>

class Container
{
public:
  using value_type = int;
  class iterator
  {
  public:
    iterator(value_type* ptr) : ptr(ptr) {}

    bool        operator==(const iterator& rhs) const { return ptr == rhs.ptr; }
    bool        operator!=(const iterator& rhs) const { return !(*this == rhs); }
    iterator&   operator++() { ptr++; return *this; }
    iterator    operator++(int) { auto t = *this; ++(*this); return t; }
    value_type& operator*() { return *ptr; }

  private:
    value_type* ptr;
  };

  explicit Container(size_t size)
    : data(new value_type[size * sizeof(value_type)]), size(size)
  {}

  virtual ~Container() { delete[] data; }

  iterator begin() { return iterator(data); }
  iterator end() { return iterator(data + size); }

private:
  value_type* data;
  size_t      size;
};

int main()
{
  Container cont(5);
  
  std::iota(cont.begin(), cont.end(), 0); // 使用 C++ STL 算法

  // 当作指针使用
  for(auto it = cont.begin(); it != cont.end(); it++)
    std::cout << *it << " ";
  std::cout << '\n';

  // 使用 C++ for-each
  for(auto it : cont)
    std::cout << it << " ";
  std::cout << '\n';

  return 0;
}
```

执行结果:  

```
0 1 2 3 4 
0 1 2 3 4
```

可见实现了迭代器不仅能使遍历方法保持一致, 而且还能配合 C++ 的 STL 和 for-each 使用.  
下面提供一种迭代器算法的简单实现:  

```cpp
template <typename Iter>
size_t distance(Iter begin, Iter end)
{
  size_t dis = 0;
  for(auto it = begin; it != end; it++)
    dis++;
  return dis;
}
```

但上面的代码若用在数组等结构上存在效率问题, 因此还需要根据数据结构的特性对其迭代器进行分类, 以便采用合适的算法. 详情请参考 [std::iterator](https://en.cppreference.com/w/cpp/iterator/iterator).  